{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\risha\\\\Music\\\\connect-four-main\\\\frontend\\\\src\\\\components\\\\Board.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from \"react\";\nimport { Slot } from \"./Slot\";\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const Board = () => {\n  _s();\n  // 6 rows, 7 columns\n  // Could have done with a nested for loop but this way is more visual\n  const [board, setBoard] = useState([['', '', '', '', '', '', ''], ['', '', '', '', '', '', ''], ['', '', '', '', '', '', ''], ['', '', '', '', '', '', ''], ['', '', '', '', '', '', ''], ['', '', '', '', '', '', '']]);\n  const [currPlayer, setCurrPlayer] = useState('X');\n  const [oppPlayer, setOppPlayer] = useState('O');\n  const [gameOver, setGameOver] = useState(false);\n  const checkWin = (row, column, ch) => {\n    // EXERCISE: This function does not cover all possible winning combinations. Edit the code to cover all possibilities. A working solution in C# (don't worry--if you know JavaScript you should understand most of it) exists at https://dotnetfiddle.net/FZGpbS Line #128\n    try {\n      if (board[row + 1][column] === ch) {\n        if (board[row + 2][column] === ch) {\n          if (board[row + 3][column] === ch) {\n            return true;\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n    try {\n      if (board[row + 1][column + 1] === ch) {\n        if (board[row + 2][column + 2] === ch) {\n          if (board[row + 3][column + 3] === ch) {\n            return true;\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n    try {\n      if (board[row + 1][column - 1] === ch) {\n        if (board[row + 2][column - 2] === ch) {\n          if (board[row + 3][column - 3] === ch) {\n            return true;\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n    try {\n      if (board[row][column + 1] === ch) {\n        if (board[row][column + 2] === ch) {\n          if (board[row][column + 3] === ch) {\n            return true;\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n    try {\n      if (board[row][column - 1] === ch) {\n        if (board[row][column - 2] === ch) {\n          if (board[row][column - 3] === ch) {\n            return true;\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n    try {\n      if (board[row - 1][column - 1] === ch) {\n        if (board[row - 2][column - 2] === ch) {\n          if (board[row - 3][column - 3] === ch) {\n            return true;\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n    try {\n      if (board[row - 1][column + 1] === ch) {\n        if (board[row - 2][column + 2] === ch) {\n          if (board[row - 3][column + 3] === ch) {\n            return true;\n          }\n        }\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  };\n  const updateBoard = (row, column, ch) => {\n    setBoard(prev => {\n      const boardCopy = [...prev];\n      boardCopy[row][column] = ch;\n      return boardCopy;\n    });\n    return checkWin(row, column, ch);\n  };\n  const handleClick = e => {\n    const column = e.target.getAttribute('x');\n    let row = board.findIndex((rowArr, index) => {\n      // Find the first row that is occupied or at the bottom of the board\n      return rowArr[column] !== '' || index === board.length - 1;\n    });\n    // Only go up one row if the slot is NOT at the bottom\n    if (row !== board.length - 1) row -= 1;\n    if (board[row][column] !== '') row -= 1;\n    setGameOver(updateBoard(row, column, currPlayer));\n    if (!gameOver) {\n      // Swap players\n      const currPlayerCopy = currPlayer;\n      setCurrPlayer(oppPlayer);\n      setOppPlayer(currPlayerCopy);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [gameOver && /*#__PURE__*/_jsxDEV(\"h1\", {\n      children: [\"Game Over! \", oppPlayer == 'X' ? 'Red' : 'Black', \" Wins!\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 17\n    }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n      id: \"playerDisplay\",\n      children: [currPlayer === 'X' ? 'Red' : 'Black', \" Move\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"board\",\n      onClick: gameOver ? null : handleClick,\n      children: board.map((row, i) => {\n        return row.map((ch, j) => /*#__PURE__*/_jsxDEV(Slot, {\n          ch: ch,\n          y: i,\n          x: j\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 141,\n          columnNumber: 47\n        }, this));\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 136,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true);\n};\n_s(Board, \"EIP9YhglqBGv0PYLlGrRqVjBYf0=\");\n_c = Board;\nvar _c;\n$RefreshReg$(_c, \"Board\");","map":{"version":3,"names":["React","useState","useEffect","Slot","jsxDEV","_jsxDEV","Fragment","_Fragment","Board","_s","board","setBoard","currPlayer","setCurrPlayer","oppPlayer","setOppPlayer","gameOver","setGameOver","checkWin","row","column","ch","e","console","log","updateBoard","prev","boardCopy","handleClick","target","getAttribute","findIndex","rowArr","index","length","currPlayerCopy","children","fileName","_jsxFileName","lineNumber","columnNumber","id","onClick","map","i","j","y","x","_c","$RefreshReg$"],"sources":["C:/Users/risha/Music/connect-four-main/frontend/src/components/Board.jsx"],"sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport { Slot } from \"./Slot\";\n\n\nexport const Board = () => {\n    // 6 rows, 7 columns\n    // Could have done with a nested for loop but this way is more visual\n    const [board, setBoard] = useState([\n        ['', '', '', '', '', '', ''],\n        ['', '', '', '', '', '', ''],\n        ['', '', '', '', '', '', ''],\n        ['', '', '', '', '', '', ''],\n        ['', '', '', '', '', '', ''],\n        ['', '', '', '', '', '', '']\n    ]);\n\n    const [currPlayer, setCurrPlayer] = useState('X');\n    const [oppPlayer, setOppPlayer] = useState('O');\n    const [gameOver, setGameOver] = useState(false);\n\n\n    const checkWin = (row, column, ch) => {\n        // EXERCISE: This function does not cover all possible winning combinations. Edit the code to cover all possibilities. A working solution in C# (don't worry--if you know JavaScript you should understand most of it) exists at https://dotnetfiddle.net/FZGpbS Line #128\n        try {\n            if (board[row + 1][column] === ch) {\n                if (board[row + 2][column] === ch) {\n                    if (board[row + 3][column] === ch) {\n                        return true;\n                    }\n                }\n            }\n        } catch (e) { console.log(e) }\n\n        try {\n            if (board[row + 1][column + 1] === ch) {\n                if (board[row + 2][column + 2] === ch) {\n                    if (board[row + 3][column + 3] === ch) {\n                        return true;\n                    }\n                }\n            }\n        } catch (e) { console.log(e) }\n\n        try {\n            if (board[row + 1][column - 1] === ch) {\n                if (board[row + 2][column - 2] === ch) {\n                    if (board[row + 3][column - 3] === ch) {\n                        return true;\n                    }\n                }\n            }\n        } catch (e) { console.log(e) }\n\n        try {\n            if (board[row][column + 1] === ch) {\n                if (board[row][column + 2] === ch) {\n                    if (board[row][column + 3] === ch) {\n                        return true;\n                    }\n                }\n            }\n        } catch (e) { console.log(e) }\n\n        try {\n            if (board[row][column - 1] === ch) {\n                if (board[row][column - 2] === ch) {\n                    if (board[row][column - 3] === ch) {\n                        return true;\n                    }\n                }\n            }\n        } catch (e) { console.log(e) }\n\n        try {\n            if (board[row - 1][column - 1] === ch) {\n                if (board[row - 2][column - 2] === ch) {\n                    if (board[row - 3][column - 3] === ch) {\n                        return true;\n                    }\n                }\n            }\n        } catch (e) { console.log(e) }\n\n        try {\n            if (board[row - 1][column + 1] === ch) {\n                if (board[row - 2][column + 2] === ch) {\n                    if (board[row - 3][column + 3] === ch) {\n                        return true;\n                    }\n                }\n            }\n        } catch (e) { console.log(e) }\n    };\n\n    const updateBoard = (row, column, ch) => {\n        setBoard(prev => {\n            const boardCopy = [...prev];\n            boardCopy[row][column] = ch;\n            return boardCopy;\n        });\n        return checkWin(row, column, ch);\n    };\n\n\n    const handleClick = (e) => {\n        const column = e.target.getAttribute('x');\n        let row = board.findIndex((rowArr, index) => {\n            // Find the first row that is occupied or at the bottom of the board\n            return (rowArr[column] !== '' || (index === board.length - 1));\n        });\n        // Only go up one row if the slot is NOT at the bottom\n        if (row !== (board.length - 1)) row -= 1;\n        if (board[row][column] !== '') row -= 1;\n\n\n\n        setGameOver(updateBoard(row, column, currPlayer));\n\n\n        if (!gameOver) {\n            // Swap players\n            const currPlayerCopy = currPlayer;\n            setCurrPlayer(oppPlayer);\n            setOppPlayer(currPlayerCopy);\n        }\n\n    };\n\n\n    return (\n        <>\n            {gameOver && (\n                <h1>Game Over! {oppPlayer == 'X' ? 'Red' : 'Black'} Wins!</h1>\n            )}\n            <h2 id='playerDisplay'>{currPlayer === 'X' ? 'Red' : 'Black'} Move</h2>\n            <div id='board'\n                onClick={gameOver ? null : handleClick}\n            >\n\n                {board.map((row, i) => {\n                    return row.map((ch, j) => <Slot ch={ch} y={i} x={j} />);\n                })}\n            </div>\n        </>\n    );\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}